/**
 * Router: Fish-style autocomplete with multiple sources
 * Supports: history-only, LLM-only, or hybrid
 */

import { useEffect, useRef } from 'react';
import type { Terminal as XTermTerminal } from '@xterm/xterm';
import { invoke } from '@tauri-apps/api/core';
import { SimpleAutocomplete } from './autocomplete/simple';
import { LLMInlineAutocomplete } from './autocomplete/llm-inline';

export function useAutocompleteSimple(
  terminalRef: React.RefObject<XTermTerminal | null>,
  enabled: boolean,
  ptyId: number,
  source: 'history' | 'llm' | 'hybrid' = 'history',
) {
  const historyEngineRef = useRef<SimpleAutocomplete | null>(null);
  const llmEngineRef = useRef<LLMInlineAutocomplete | null>(null);
  const onDataDisposerRef = useRef<{ dispose: () => void } | null>(null);

  console.log('ðŸŽ¯ Autocomplete source:', source);

  // Initialize engines based on source
  useEffect(() => {
    if (!enabled) return;

    // Always init history engine for hybrid mode
    if ((source === 'history' || source === 'hybrid') && !historyEngineRef.current) {
      historyEngineRef.current = new SimpleAutocomplete();
      console.log('ðŸ“š History engine initialized');
    }

    // Init LLM engine if needed
    if ((source === 'llm' || source === 'hybrid') && !llmEngineRef.current) {
      llmEngineRef.current = new LLMInlineAutocomplete();
      const modelPath = '~/.config/aiterminal/models/qwen3-0.6b-q4_k_m.gguf';
      llmEngineRef.current.initialize(modelPath).catch(console.error);
      console.log('ðŸ¤– LLM engine initializing...');
    }
  }, [enabled, source]);

  // Load history (for history and hybrid modes)
  useEffect(() => {
    if (!enabled || !historyEngineRef.current) return;

    const loadHistory = async () => {
      try {
        const history = await invoke<string[]>('get_shell_history');
        historyEngineRef.current?.updateHistory(history);
      } catch (error) {
        console.error('Failed to load shell history:', error);
      }
    };

    loadHistory();
    const interval = setInterval(loadHistory, 10000);
    return () => clearInterval(interval);
  }, [enabled, source]);

  // Handle keyboard - route to appropriate engine
  useEffect(() => {
    const terminal = terminalRef.current;
    const historyEngine = historyEngineRef.current;
    const llmEngine = llmEngineRef.current;
    
    if (!enabled || !terminal) {
      if (onDataDisposerRef.current) {
        onDataDisposerRef.current.dispose();
        onDataDisposerRef.current = null;
      }
      return;
    }

    // Dispose previous listener
    if (onDataDisposerRef.current) {
      onDataDisposerRef.current.dispose();
    }

    // Use onKey instead of onData - fires BEFORE PTY gets the data
    const disposer = terminal.onKey((event) => {
      const domKey = event.domEvent.key;
      
      // Route based on source
      if (source === 'history' && historyEngine) {
        handleHistoryMode(event, domKey, terminal, historyEngine, ptyId);
      } else if (source === 'llm' && llmEngine) {
        handleLLMMode(event, domKey, terminal, llmEngine, ptyId);
      } else if (source === 'hybrid' && historyEngine && llmEngine) {
        handleHybridMode(event, domKey, terminal, historyEngine, llmEngine, ptyId);
      }
    });

    onDataDisposerRef.current = disposer;

    return () => {
      if (onDataDisposerRef.current) {
        onDataDisposerRef.current.dispose();
        onDataDisposerRef.current = null;
      }
    };
  }, [enabled, terminalRef, ptyId, source]);
}

// Helper: History-only mode (current behavior)
function handleHistoryMode(
  event: any,
  domKey: string,
  terminal: XTermTerminal,
  engine: SimpleAutocomplete,
  ptyId: number
) {
  // Right arrow â†’ accept suggestion
  if (domKey === 'ArrowRight') {
    const toInsert = engine.acceptSuggestion();
    if (toInsert) {
      engine.clearRender(terminal);
      invoke('write_to_pty', { id: ptyId, data: toInsert }).catch(console.error);
      event.domEvent.preventDefault();
          event.domEvent.stopPropagation();
          return;
        }
      }

      // Enter â†’ reset
      if (domKey === 'Enter') {
        autocomplete.clearRender(terminal);
        autocomplete.onEnter();
        return;
      }

      // Backspace
      if (domKey === 'Backspace') {
        autocomplete.clearRender(terminal);
        autocomplete.onBackspace();
        setTimeout(() => autocomplete.render(terminal), 10);
        return;
      }

      // Ctrl+C â†’ clear
      if (domKey === 'c' && event.domEvent.ctrlKey) {
        autocomplete.clearRender(terminal);
        autocomplete.onClear();
        return;
      }

      // Regular printable character
      if (domKey.length === 1 && !event.domEvent.ctrlKey && !event.domEvent.metaKey && !event.domEvent.altKey) {
        autocomplete.clearRender(terminal);
        autocomplete.onChar(domKey);
        setTimeout(() => autocomplete.render(terminal), 10);
      }
    });

    onDataDisposerRef.current = disposer;

    return () => {
      disposer.dispose();
    };
  }, [enabled, terminalRef.current]); // Re-run when terminal becomes available

  return null;
}
